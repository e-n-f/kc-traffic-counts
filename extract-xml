#!/usr/bin/perl

use strict;

my @x = ();
my @y = ();
my @min = ();
my @max = ();
my @text = ();
my $group = "";
my $date = "";
my $street = "";
my %warn;
my %used;

while (<>) {
	s/<[bi]>//g;
	s/<\/[bi]>//g;

	$warn{$ARGV} = 1;

	if (/<text top="([0-9]+)" left="([0-9]+)" width="([0-9]+)" height="([0-9]+)" font="[^"]*">(.*)<\/text>/) {
		my $x = $2 + $3 / 2;
		my $y = $1 + $4 / 2;
		my $text = $5;

		$text =~ s/&gt;/>/g;
		$text =~ s/&lt;/</g;
		$text =~ s/&amp;/\&/g;

		push @x, $x;
		push @y, $y;
		push @min, $2;
		push @max, $2 + $3;
		push @text, $text;
	}

	if (/<\/page/) {
		my $i;
		for ($i = 0; $i <= $#text; $i++) {
			if ($text[$i] =~ /Start Date\s*:\s*(.*)/) {
				$date = $1;
				$date =~ s/,/ /g;
			}

			if ($text[$i] =~ /Groups *Printed *-? *(.*)/ ||
			    $text[$i] =~ /Turning *Movement *Data/) {
				my @streets = ();
				my @directions = ();
				my @directionx = ();

				if ($text[$i] =~ /Turning *Movement *Data/) { 
					$i++;
					$group = "x";

					if ($text[$i] =~ /Start Time/) {
						$i++;
					}

					for (; $i <= $#text; $i++) {
						if ($text[$i] =~ /bound$/i || $text[$i] =~ /\([NSEW]B\)$/ || $text[$i] =~ /^From/i || $text[$i] =~ /Leg$/i) {
							last;
						}

						push @streets, $text[$i];
					}
					for (; $i <= $#text; $i++) {
						unless ($text[$i] =~ /bound$/i || $text[$i] =~ /\([NSEW]B\)$/ || $text[$i] =~ /^From/i || $text[$i] =~ /Leg$/i) {
							last;
						}

						push @directions, $text[$i];
						push @directionx, $x[$i];
					}
				} else {
					$group = $1;
					$group =~ s/ +/ /g;
					# print "$ARGV\n";
					# print "$group\n";
					$i++;

					my $direction = 0;
					my $prevx = 0;
					my $prevy = 0;
					for (; $i <= $#text; $i++) {
						if ($text[$i] =~ /bound$/i || $text[$i] =~ /\([NSEW]B\)$/ || $text[$i] =~ /^From/i || $text[$i] =~ /Leg$/i || $text[$i] =~ /Approach$/i) {
							$directions[$direction] = $text[$i];
							$directionx[$direction] = $x[$i];

							if ($text[$i] eq "From") {
								$directions[$direction] .= " $text[$i + 1]";
								$i++;
							}

							$directions[$direction] =~ s/ *\([NSEW]B\) *//g;
							$directions[$direction] =~ s/ *Approach *//g;
							$directions[$direction] =~ s/From Northeast/Southwestbound/gi;
							$directions[$direction] =~ s/From Southeast/Northwestbound/gi;
							$directions[$direction] =~ s/From Northwest/Southeastbound/gi;
							$directions[$direction] =~ s/From Southwest/Northeastbound/gi;
							$directions[$direction] =~ s/From North/Southbound/gi;
							$directions[$direction] =~ s/From South/Northbound/gi;
							$directions[$direction] =~ s/From East/Westbound/gi;
							$directions[$direction] =~ s/From West/Eastbound/gi;
							$directions[$direction] =~ s/North Leg/Southbound/gi;
							$directions[$direction] =~ s/South Leg/Northbound/gi;
							$directions[$direction] =~ s/East Leg/Westbound/gi;
							$directions[$direction] =~ s/West Leg/Eastbound/gi;
							$directions[$direction] =~ s/NORTHBOUND/Northbound/gi;
							$directions[$direction] =~ s/SOUTHBOUND/Southbound/gi;
							$directions[$direction] =~ s/\bEASTBOUND/Eastbound/gi;
							$directions[$direction] =~ s/\bWESTBOUND/Westbound/gi;

							$prevy = 0;
							$direction++;
						} elsif ($text[$i] =~ /Start/) {
							last;
						} else {
							if ($y[$i] <= $prevy) {
								$directionx[$direction] = $prevx;
								$directions[$direction] = "Not specified";
								$direction++;
							}

							if ($streets[$direction] eq "") {
								$streets[$direction] = $text[$i];
							} else {
								$streets[$direction] .= " $text[$i]";
							}

							$prevx = $x[$i];
							$prevy = $y[$i];
							$directionx[$direction] = $x[$i]; # Usually overwritten
						}
					}
				}

				$street = "";
				my %street = ();

				for (my $x = 0; $x <= $#streets; $x++) {
					$streets[$x] =~ s/ *$//;
					$streets[$x] =~ s/ +/ /g;

                                        if ($streets[$x] ne "" && !defined($street{$streets[$x]})) {
                                                if ($street eq "") {
                                                        $street = $streets[$x];
                                                } else {
                                                        $street .= " / $streets[$x]";
                                                }
                                                $street{$streets[$x]} = 1;
                                        }
					# print "$streets[$x]: $directions[$x] $directionx[$x]\n";
				}

				if ($text[$i] =~ /Start/) {
					$i++;
				}
				if ($text[$i] =~ /Time/) {
					$i++;
				}

				my @cols = ();
				my @colmin = ();
				my @colmax = ();
				for (; $i <= $#text; $i++) {
					last if $text[$i] =~ /\d:\d\d/;
					last if $text[$i] =~ /Factor/;

					if ($#colmin >= 0 &&
					    ! ($min[$i] > $colmax[$#colmax] || $max[$i] < $colmin[$#colmin])) {
						$cols[$#cols] .= $text[$i];
						if ($min[$i] < $colmin[$#colmin]) {
							$colmin[$#colmin] = $min[$i];
						}
						if ($max[$i] > $colmax[$#colmax]) {
							$colmax[$#colmax] = $max[$i];
						}
					} else {
						push @cols, $text[$i];
						push @colmin, $min[$i];
						push @colmax, $max[$i];
					}
				}

				my @coldir = ();
				for (my $x = 0; $x <= $#cols; $x++) {
					$cols[$x] =~ s/Rght/Right/gi;

					my $mid = ($colmin[$x] + $colmax[$x]) / 2;
					my $best = -1;
					my $bestdist = 999999;
					for (my $y = 0; $y <= $#directions; $y++) {
						my $d = abs($mid - $directionx[$y]);
						if ($d < $bestdist) {
							$best = $y;
							$bestdist = $d;
						}
					}

					$coldir[$x] = $best;
				}

				if (
					$group eq "Peds and Bicycles" ||
					$group eq "Bicycles" ||
					$group eq "BIKES" ||
					$group eq "BIKES PEDS" ||
					$group eq "Bikes" ||
					$group eq "2 - Bicycles" ||
					$group eq "Bike_Peds" ||
					$group eq "Bicycles Only" ||
					$group eq "Bikes/Peds" ||
					$group eq "Bicycle" ||
					$group eq "2 - 2 - Bicycles" ||
					$group eq "Pedal Bikes" ||
					$group eq "Bicycles/Peds" ||
					$group eq "Bikes & Peds" ||
					$group eq "Bikes Peds" ||
					$group eq "Bikes_Peds" ||
					$group eq "Bicycles and Pedestrians" ||
					$group eq "Bicycles/Pedestrians" ||
					$group eq "Bikes / Peds" ||
					$group eq "Peds - Bikes" ||
					$group eq "Pedestrians - Bikes" ||
					$group eq "Bikes / Pedestrians" ||
					$group eq "Bikes - Bank 2" ||
					$group eq "Bicyclists" ||
					$group eq "Bikes (Acting as Pedestrians)" ||
					$group eq "Peds/Bikes" ||
					0
				) {
					for (my $x = 0; $x <= $#cols; $x++) {
						if ($cols[$x] eq "Right") {
							$cols[$x] = "RightBikes";
						} elsif ($cols[$x] eq "Left") {
							$cols[$x] = "LeftBikes";
						} elsif ($cols[$x] eq "Thru") {
							$cols[$x] = "ThruBikes";
						}
					}
				}

				for (my $x = 0; $x <= $#cols; $x++) {
					# print "$directions[$coldir[$x]]: $cols[$x]: $colmin[$x] to $colmax[$x]\n";
				}

				my $when = -1;
				my %val = ();
				for (; $i <= $#text; $i++) {
					last if ($text[$i] =~ /Grand/);

					if ($text[$i] =~ /(\d+):(\d+) *([AP]M)?/) {
						my $hour = $1;
						my $minute = $2;
						if ($3 eq "PM" && $hour != 12) {
							$hour += 12;
						}
						$when = $hour * 60 + $minute;
					} elsif ($text[$i] =~ /Total/) {
						$when = -1;
					} elsif ($text[$i] =~ /^ *(\d+) *$/) {
						my $v = $1;
						my $best = -1;
						my $bestd = 999999;
						for (my $x = 0; $x <= $#cols; $x++) {
							my $d = abs($x[$i] - ($colmin[$x] + $colmax[$x]) / 2);
							if ($d < $bestd) {
								$best = $x;
								$bestd = $d;
							}
						}

						if ($when >= 0 && defined($val{$when}{$directions[$coldir[$best]]}{$cols[$best]})) {
							# Still a bad sign, but we're not using the totals
							unless ($cols[$best] =~ /Total/) {
								# Duplicate of exactly the same value seems harmless
								unless ($val{$when}{$directions[$coldir[$best]]}{$cols[$best]} == $v) {
									print STDERR "$ARGV: already have $val{$when}{$directions[$coldir[$best]]}{$cols[$best]} for val{$when}{$directions[$coldir[$best]]}{$cols[$best]} = $v\n";
									$val{$when}{'fail'} = 1;
									$i = $#text;
								}
							}
						}
						$val{$when}{$directions[$coldir[$best]]}{$cols[$best]} = $v;
						# print "val{$when}{$directions[$coldir[$best]]}{$cols[$best]} = $v\n";
					}
				}

				for my $when (sort {$a <=> $b } (keys(%val))) {
					next if $when < 0;
					next if defined($val{$when}{'fail'});

					my $argv = $ARGV;
					$used{$ARGV} = 1;
					$argv =~ s/xml/txt/g; # XXX
					$argv =~ s/,/ /g; # XXX

					print "$argv,$street,$group,$date,";
					printf("%02d:%02d-%02d:%02d,", $when / 60, $when % 60, ($when + 15) / 60, ($when + 15) % 60);

					# Directions to intersection legs
					my %bikemap = ( "Northbound" => "Westbound",
							"Southbound" => "Eastbound",
							"Eastbound" => "Northbound",
							"Westbound" => "Southbound");

					for my $direction (keys(%bikemap)) {
						if (defined($val{$when}{$direction}{"ThruBikes"})) {
							$val{$when}{$bikemap{$direction}}{"Bikes"} =
								$val{$when}{$direction}{"ThruBikes"};
							delete $val{$when}{$direction}{"ThruBikes"};
						}
					}

					for my $direction ('Southbound', 'Westbound', 'Northbound', 'Eastbound') {
						for my $turn ('Right', 'Thru', 'Left') {
							print "$val{$when}{$direction}{$turn},";
							delete $val{$when}{$direction}{$turn};
						}
					}

					for my $turn ('Peds', 'Bikes') {
						for my $direction ('Southbound', 'Westbound', 'Northbound', 'Eastbound') {
							print "$val{$when}{$direction}{$turn},";
							delete $val{$when}{$direction}{$turn};
						}
					}

					print ",";  # XXX

					for my $direction (keys(%{$val{$when}})) {
						for my $turn (keys(%{$val{$when}{$direction}})) {
							next if $turn =~ /Total/;
							next if $turn =~ /U-Turn/;
							next if $turn =~ /RightBikes/;
							next if $turn =~ /LeftBikes/;

							print ",$direction:$turn:$val{$when}{$direction}{$turn}";
						}
					}

					print "\n";
				}

				# print "\n";
			}
		}

		@x = ();
		@y = ();
		@min = ();
		@max = ();
		@text = ();
		$group = "";
		$date = "";
		$street = "";
	}
}

for my $file (keys(%warn)) {
	unless ($used{$file}) {
		print STDERR "$file: no output\n";
	}
}
