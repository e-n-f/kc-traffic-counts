#!/usr/bin/perl

use strict;

my %lat;
my %lon;
open(IN, "Traffic_Counts_at_Signals.csv");
while (<IN>) {
	if (/"\(([0-9.-]+), ([0-9.-]+)\)",https?:\/\/data.kcmo.org\/Traffic\/([^\/]*)/) {
		$lat{$3} = $1;
		$lon{$3} = $2;
	}
}
close(IN);

my $fname = "";

my $date = "";
my $group = "";
my $street = "";
my $streethdr = "";
my @directions = ();
my @cols = ();
my %val = ();
my @times = ();

sub out {
	my $fname;
	for $fname (keys(%val)) {
		my $street;
		for $street (keys(%{$val{$fname}})) {
			my $date;
			for $date (sort(keys(%{$val{$fname}{$street}}))) {
				my $time;
				for $time (sort { $a <=> $b } (keys(%{$val{$fname}{$street}{$date}}))) {
					print "$fname,$street,$group,$date,";

					my $gap1 = -1;
					my $gap2 = -2;
					if ($time - 1 >= 0) {
						$gap1 = $times[$time] - $times[$time - 1];
					}
					if ($time + 1 <= $#times) {
						$gap2 = $times[$time + 1] - $times[$time];
					}

					my $gap;  # choose smallest gap that is >= 0
					if ($gap1 <= 0) {
						$gap = $gap2;
					} elsif ($gap2 <= 0) {
						$gap = $gap1;
					} elsif ($gap1 < $gap2) {
						$gap = $gap1;
					} else {
						$gap = $gap2;
					}

					printf("%02d:%02d-%02d:%02d,", $times[$time] / 60, $times[$time] % 60, ($times[$time] + $gap) / 60, ($times[$time] + $gap) % 60);

					my $dir;
					for $dir ("Southbound", "Westbound", "Northbound", "Eastbound") {
						my $turn;
						for $turn ("Right", "Thru", "Left") {
							# print "$dir $turn ";
							print "$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
							delete $val{$fname}{$street}{$date}{$time}{$dir}{$turn};
						}
					}

					for $dir ("Southbound", "Westbound", "Northbound", "Eastbound") {
						my $turn;
						for $turn ("Peds") {
							print "$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
							delete $val{$fname}{$street}{$date}{$time}{$dir}{$turn};
						}
					}

					for $dir ("Westbound", "Northbound", "Eastbound", "Southbound") {
						my $turn;
						for $turn ("ThruBikes") {
							print "$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
							delete $val{$fname}{$street}{$date}{$time}{$dir}{$turn};
						}
					}

					if ($fname =~ /kc\/(.*)\.txt/) {
						print "$lat{$1},$lon{$1}";
					} else {
						print ",";
					}

					if (0) {
						for $dir (keys(%{$val{$fname}{$street}{$date}{$time}})) {
							my $turn;
							for $turn (keys(%{$val{$fname}{$street}{$date}{$time}{$dir}})) {
								unless ($turn =~ /Total/) {
									print "$dir:$turn:$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
								}
							}
						}
					}

					print "\n";
				}
			}
		}
	}
}

sub space {
	my ($i, @rows) = @_;

	my $j;
	for ($j = 0; $j <= $#rows; $j++) {
		# print "looking at $i in $rows[$j]\n";
		if (substr($rows[$j], $i, 1) =~ /[^ ]/) {
			# print "not a space\n";
			return 0;
		}
	}

	# print "all spaces\n";
	return 1;
}

sub parse_cols {
	$_ = <>;
	while ($_ ne "") {
		if (/North/ || /South/ || /East/ || /West/ || /bound/) {
			last;
		}

		$_ = <>;
	}

	chomp;
	s/^\s*//;
	s/ \([NSEW]B\)//g;
	s/\bFrom\s*East\b/Westbound/g;
	s/\bFrom\s*West\b/Eastbound/g;
	s/\bFrom\s*North\b/Southbound/g;
	s/\bFrom\s*South\b/Northbound/g;
	s/\bFrom\s*Northeast\b/Southwestbound/g;
	s/\bFrom\s*Northwest\b/Southeastbound/g;
	s/\bFrom\s*Southeast\b/Northwestbound/g;
	s/\bFrom\s*Southwest\b/Northeastbound/g;
	s/\bEast\s*Leg\b/Westbound/g;
	s/\bWest\s*Leg\b/Eastbound/g;
	s/\bNorth\s*Leg\b/Southbound/g;
	s/\bSouth\s*Leg\b/Northbound/g;
	s/bound\s*Approach\b/bound/g;
	@directions = split(/   +/, $_);
	@cols = ();

	my @hdr = ();
	my $max = 0;
	while (1) {
		$_ = <>;
		last if $_ eq "" || $_ =~ /[0-9\*]/;
		chomp;
		push @hdr, $_;

		if (length($_) > $max) {
			$max = length($_);
		}
	}

	my $broke = $_;
	my $line = "";
	my $i;
	for ($i = 0; $i < $max; $i++) {
		if (!space($i, @hdr)) {
			my $j;
			for ($j = $i + 1; $j < $max; $j++) {
				last if space($j, @hdr);
			}

			# print "so it's $i to $j\n";

			my $f = "";
			my $n;
			for ($n = 0; $n <= $#hdr; $n++) {
				# print substr($hdr[$n], $i, $j - $i) . "\n";
				$f .= substr($hdr[$n], $i, $j - $i);
			}
			$f =~ s/\s//g;

			$line .= "$f ";
			$i = $j - 1;
		}
	}

	# print "header: $line\n";

	$_ = $line;
	if (s/^\s*Start\s*Time\s*//) {
		chomp;
		s/\.\s*Total/\.Total/g;
		s/\s*\([^)]*\)//g;
		s/\bRT\b/Right/gi;
		s/\bLT\b/Left/gi;
		s/\bTH\b/Thru/gi;
		s/\bRght\b/Right/gi;
		s/\bRight *on *red/RTOR/gi;
		s/\bU Turns/U-turn/gi;
		s/\bUTurn/U-turn/gi;
		s/\bU-TR/U-turn/gi;
		s/\bU-Turns/U-turn/gi;
		s/(\d) Axles/\1Axles/gi;
		s/\bBear /Bear/gi;
		s/\bHard /Hard/gi;
		s/\bHd /Hard/gi;
		s/\bBr /Bear/gi;
		s/\bThruLeft\b/Thru Left/gi;
		s/\bThruRight\b/Thru Right/gi;
		s/\bRightThru\b/Right Thru/gi;
		s/\bLeft Thru\b/Left Thru/gi;
		s/\bLeftRight\b/Left Right/gi;
		s/\bRightLeft\b/Right Left/gi;
		@cols = split(/ +/, $_);

		if (
			$group eq "Peds and Bicycles" ||
			$group eq "Bicycles" ||
			$group eq "BIKES" ||
			$group eq "BIKES PEDS" ||
			$group eq "Bikes" ||
			$group eq "2 - Bicycles" ||
			$group eq "Bike_Peds" ||
			$group eq "Bicycles Only" ||
			$group eq "Bikes/Peds" ||
			$group eq "Bicycle" ||
			$group eq "2 - 2 - Bicycles" ||
			$group eq "Pedal Bikes" ||
			$group eq "Bicycles/Peds" ||
			$group eq "Bikes & Peds" ||
			$group eq "Bikes Peds" ||
			$group eq "Bikes_Peds" ||
			$group eq "Bicycles and Pedestrians" ||
			$group eq "Bicycles/Pedestrians" ||
			$group eq "Bikes / Peds" ||
			$group eq "Peds - Bikes" ||
			$group eq "Pedestrians - Bikes" ||
			$group eq "Bikes / Pedestrians" ||
			$group eq "Bikes - Bank 2" ||
			$group eq "Bicyclists" ||
			$group eq "Bikes (Acting as Pedestrians)" ||
			$group eq "Peds/Bikes" ||
			0
		) {
			my $i;
			for ($i = 0; $i <= $#cols; $i++) {
				if ($cols[$i] ne "Peds") {
					$cols[$i] .= "Bikes";
				}
			}
		}

		$_ = $broke;
	} else {
		print STDERR "$fname: Expected columns, not $_\n";
	}
}

while (<>) {
	chomp;

	if (/\014/) {
		out();

		$date = "";
		$group = "";
		$street = "";
		$streethdr = "";
		@directions = ();
		@cols = ();
		%val = ();
		@times = ();
	}

	if (/Start\s*Date\s*:\s*(.*)/) {
		$date = $1;
		$date =~ s/,/ /g;
	} elsif (/(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (.*)/) {
		$date = $2;
		$date =~ s/,/ /g;
		$date =~ s/    .*//;
	}

	if (/Groups\s*Printed\s*-?\s*(.*)/ || /Turning Movement Data/) {
		$fname = $ARGV;
		$group = $1;

		$fname =~ s/,/ /g;
		$group =~ s/,/ /g;
		$group =~ s/ +/ /g;
		$group =~ s/\s*Out\s*In.*//;

		$_ = <>;
		chomp;
		# my @streets = split(/                                                   +/, $_);
		my @streets = split(/   +/, $_);
		my %streets = ();
		$street = "";
		for (@streets) {
			s/ +/ /g;
			unless ($streets{$_}) {
				if ($street ne "") {
					$street .= " / ";
				}
				$street .= "$_";
				$streets{$_} = 1;
			}
		}
		$street =~ s/,/ /g;
		$streethdr = $_;
		$streethdr =~ s/\s*//g;

		parse_cols();
	}

	if (/Peak 15-Minute Interval Summary/) {
		$fname = $ARGV;
		$group = "";

		$fname =~ s/,/ /g;
		$group =~ s/,/ /g;

		$_ = <>; # time range

		$_ = <>;
		if (s/^\s*Interval\s*//) {
			chomp;
			@directions = split(/   +/, $_);
		} else {
			print STDERR "$fname: Expected Interval, not $_\n";
			next;
		}

		$_ = <>;
		s/^\s*Start\s*//;
		s/\s*Interval\s*$//;
		chomp;
		my @streets = split(/   +/, $_);
		my %streets = ();
		$street = "";
		for (@streets) {
			unless ($streets{$_}) {
				if ($street ne "") {
					$street .= " / ";
				}
				$street .= "$_";
				$streets{$_} = 1;
			}
		}
		$street =~ s/,/ /g;
		$streethdr = $_;
		$streethdr =~ s/\s*//g;

		$_ = <>;
		if (s/^\s*Time\s*//) {
			chomp;
			s/\s*Interval\s*$//;
			s/\.\s*Total/\.Total/g;
			s/\bR\b/Right/gi;
			s/\bL\b/Left/gi;
			s/\bT\b/Thru/gi;
			s/\bBikes\b/ThruBikes/gi;
			s/\bRT\b/Right/gi;
			s/\bLT\b/Left/gi;
			s/\bTH\b/Thru/gi;
			s/\bRght\b/Right/gi;
			s/\bU Turns/U-turn/gi;
			s/\bUTurn/U-turn/gi;
			s/\bU-TR/U-turn/gi;
			s/\bU-Turns/U-turn/gi;
			s/(\d) Axles/\1Axles/gi;
			s/\bBear /Bear/gi;
			s/\bHard /Hard/gi;
			s/\bHd /Hard/gi;
			s/\bBr /Bear/gi;
			s/\bThruLeft\b/Thru Left/gi;
			s/\bThruRight\b/Thru Right/gi;
			s/\bRightThru\b/Right Thru/gi;
			s/\bLeft Thru\b/Left Thru/gi;
			s/\bLeftRight\b/Left Right/gi;
			s/\bRightLeft\b/Right Left/gi;
			@cols = split(/ +/, $_);
		}
	}

	if ($streethdr ne "") {
		my $tmp = $_;
		chomp $tmp;
		$tmp =~ s/\s*//g;

		if ($tmp eq $streethdr) {
			parse_cols();
		}
	}

	if (/Start Time/) {
		# print STDERR "$fname: unexpected header $_\n";
		@cols = ();
	}

	if ($#cols >= 0) {
		if (!/Volume/ && s/^\s*(\d+):(\d+)\s*(.M)?\s*//) {
			my $hour = $1;
			my $min = $2;
			my $m = $3;

			if ($m eq "PM" && $hour != 12) {
				$hour += 12;
			}

			my $when = $hour * 60 + $min;
			push @times, $when;
			my $time = $#times;

			chomp;
			my @row = split(/ +/, $_);

			if ($#row != $#cols) {
				print STDERR "$fname: mismatched columns: $#cols @cols\n";
				print STDERR "$fname: mismatched row: $#row $_\n";
				next;
			}

			my $direction = 0;
			my $i;
			my %used = ();
			for ($i = 0; $i <= $#row; $i++) {
				if ($cols[$i] ne "X" && $used{$cols[$i]}) {
					$direction++;
					%used = ();
				}
				$used{$cols[$i]} = 1;

				if (1 || $row[$i] != 0) {
					$val{$fname}{$street}{$date}{$time}{$directions[$direction]}{$cols[$i]} = $row[$i];
					# print "{$fname}{$street}{$date}{$time}{$directions[$direction]}{$cols[$i]} -> $row[$i]\n";
				}

				if ($cols[$i] =~ /Total/) {
					$direction++;
					%used = ();
				} elsif ($direction > $#directions) {
					print STDERR "$fname: indexed $cols[$i] $direction past $#directions\n";
					%val = ();
					last;
				}
			}

			if ($direction < $#directions) {
				print STDERR "$fname: not all directions used: ($direction vs $#directions) $_\n";
				print STDERR "directions are:\n";
				for (@directions) {
					print STDERR " * $_\n";
				}
				%val = ();
			}
		}
	}
}

out();
