#!/usr/bin/perl

use strict;

my %lat;
my %lon;
open(IN, "Traffic_Counts_at_Signals.csv");
while (<IN>) {
	if (/"\(([0-9.-]+), ([0-9.-]+)\)",https?:\/\/data.kcmo.org\/Traffic\/([^\/]*)/) {
		$lat{$3} = $1;
		$lon{$3} = $2;
	}
}
close(IN);

my $fname = "";

my $date = "";
my $group = "";
my $street = "";
my $streethdr = "";
my @directions = ();
my @cols = ();
my %val = ();
my @times = ();

sub out {
	my $fname;
	for $fname (keys(%val)) {
		my $street;
		for $street (keys(%{$val{$fname}})) {
			my $date;
			for $date (sort(keys(%{$val{$fname}{$street}}))) {
				my $time;
				for $time (sort { $a <=> $b } (keys(%{$val{$fname}{$street}{$date}}))) {
					print "$fname,$street,$group,$date,";

					my $gap1 = -1;
					my $gap2 = -2;
					if ($time - 1 >= 0) {
						$gap1 = $times[$time] - $times[$time - 1];
					}
					if ($time + 1 <= $#times) {
						$gap2 = $times[$time + 1] - $times[$time];
					}

					my $gap;  # choose smallest gap that is >= 0
					if ($gap1 <= 0) {
						$gap = $gap2;
					} elsif ($gap2 <= 0) {
						$gap = $gap1;
					} elsif ($gap1 < $gap2) {
						$gap = $gap1;
					} else {
						$gap = $gap2;
					}

					printf("%02d:%02d-%02d:%02d,", $times[$time] / 60, $times[$time] % 60, ($times[$time] + $gap) / 60, ($times[$time] + $gap) % 60);

					my $dir;
					for $dir ("Southbound", "Westbound", "Northbound", "Eastbound") {
						my $turn;
						for $turn ("Right", "Thru", "Left") {
							# print "$dir $turn ";
							print "$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
						}
					}

					for $dir ("Southbound", "Westbound", "Northbound", "Eastbound") {
						my $turn;
						for $turn ("Peds") {
							print "$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
						}
					}

					for $dir ("Westbound", "Northbound", "Eastbound", "Southbound") {
						my $turn;
						for $turn ("Thru Bikes") {
							print "$val{$fname}{$street}{$date}{$time}{$dir}{$turn},";
						}
					}

					if ($fname =~ /kc\/(.*)\.txt/) {
						print "$lat{$1},$lon{$1}";
					} else {
						print ",";
					}

					print "\n";
				}
			}
		}
	}
}

sub space {
	my ($i, @rows) = @_;

	my $j;
	for ($j = 0; $j <= $#rows; $j++) {
		# print "looking at $i in $rows[$j]\n";
		if (substr($rows[$j], $i, 1) =~ /[^ ]/) {
			# print "not a space\n";
			return 0;
		}
	}

	# print "all spaces\n";
	return 1;
}

sub parse_cols {
	$_ = <>;
	chomp;
	s/^\s*//;
	s/\bFrom East\b/Westbound/g;
	s/\bFrom West\b/Eastbound/g;
	s/\bFrom North\b/Southbound/g;
	s/\bFrom South\b/Northbound/g;
	@directions = split(/   +/, $_);
	@cols = ();

	my @hdr = ();
	my $max = 0;
	while (1) {
		$_ = <>;
		last if $_ eq "" || $_ =~ /[0-9\*]/;
		chomp;
		push @hdr, $_;

		if (length($_) > $max) {
			$max = length($_);
		}
	}

	my $broke = $_;
	my $line = "";
	my $i;
	for ($i = 0; $i < $max; $i++) {
		if (!space($i, @hdr)) {
			my $j;
			for ($j = $i + 1; $j < $max; $j++) {
				last if space($j, @hdr);
			}

			# print "so it's $i to $j\n";

			my $f = "";
			my $n;
			for ($n = 0; $n <= $#hdr; $n++) {
				# print substr($hdr[$n], $i, $j - $i) . "\n";
				$f .= substr($hdr[$n], $i, $j - $i);
			}
			$f =~ s/\s//g;

			$line .= "$f ";
			$i = $j - 1;
		}
	}

	# print "header: $line\n";

	$_ = $line;
	if (s/^\s*Start Time\s*//) {
		chomp;
		s/\.\s*Total/\.Total/g;
		s/\bRT\b/Right/gi;
		s/\bLT\b/Left/gi;
		s/\bTH\b/Thru/gi;
		s/\bRght\b/Right/gi;
		s/\bUTurn\b/U-turn/gi;
		s/\bU-TR\b/U-turn/gi;
		s/\bU-Turns\b/U-turn/gi;
		s/\bBear /Bear/gi;
		s/\bHard /Hard/gi;
		s/\bHd /Hard/gi;
		s/\bBr /Bear/gi;
		@cols = split(/ +/, $_);

		if ($group =~ /Bicycle/i || ($group =~ /Bike/i && !($group =~ /Motor bike/i))) {
			my $i;
			for ($i = 0; $i <= $#cols; $i++) {
				if ($cols[$i] ne "Peds") {
					$cols[$i] .= " Bikes";
				}
			}
		}

		$_ = $broke;
	} else {
		print STDERR "$fname: Expected columns, not $_\n";
	}
}

while (<>) {
	chomp;

	if (/\014/) {
		out();

		$date = "";
		$group = "";
		$street = "";
		$streethdr = "";
		@directions = ();
		@cols = ();
		%val = ();
		@times = ();
	}

	if (/Start Date\s*:\s*(.*)/) {
		$date = $1;
		$date =~ s/,/ /g;
	}

	if (/Groups Printed\s*-?\s*(.*)/) {
		$fname = $ARGV;
		$group = $1;

		$fname =~ s/,/ /g;
		$group =~ s/,/ /g;

		$_ = <>;
		chomp;
		my @streets = split(/   +/, $_);
		my %streets = ();
		$street = "";
		for (@streets) {
			unless ($streets{$_}) {
				if ($street ne "") {
					$street .= " / ";
				}
				$street .= "$_";
				$streets{$_} = 1;
			}
		}
		$street =~ s/,/ /g;
		$streethdr = $_;
		$streethdr =~ s/\s*//g;

		parse_cols();
	}

	if ($streethdr ne "") {
		my $tmp = $_;
		chomp $tmp;
		$tmp =~ s/\s*//g;

		if ($tmp eq $streethdr) {
			parse_cols();
		}
	}

	if (/Start Time/) {
		print STDERR "$fname: unexpected header $_\n";
		@cols = ();
	}

	if ($#cols >= 0) {
		if (s/^\s*(\d+):(\d+)\s*(.M)?\s*//) {
			my $hour = $1;
			my $min = $2;
			my $m = $3;

			if ($m eq "PM" && $hour != 12) {
				$hour += 12;
			}

			my $when = $hour * 60 + $min;
			push @times, $when;
			my $time = $#times;

			chomp;
			my @row = split(/ +/, $_);

			if ($#row != $#cols) {
				print STDERR "$fname: mismatched columns $#cols, $#row @cols in $_\n";
				next;
			}

			my $direction = 0;
			my $i;
			my %used = ();
			for ($i = 0; $i <= $#row; $i++) {
				if ($used{$cols[$i]}) {
					$direction++;
					%used = ();
				}
				$used{$cols[$i]} = 1;

				if (1 || $row[$i] != 0) {
					$val{$fname}{$street}{$date}{$time}{$directions[$direction]}{$cols[$i]} = $row[$i];
					# print "{$fname}{$street}{$date}{$time}{$directions[$direction]}{$cols[$i]} -> $row[$i]\n";
				}

				if ($cols[$i] =~ /Total/) {
					$direction++;
					%used = ();
				} elsif ($direction > $#directions) {
					print STDERR "$fname: indexed $direction past $#directions\n";
					%val = ();
					last;
				}
			}

			if ($direction < $#directions) {
				print STDERR "$fname: not all directions used: $_\n";
				%val = ();
			}
		}
	}
}

out();
