#!/usr/bin/perl

use strict;

my @lines;
my @argv;
while (<>) {
	chomp;
	push @lines, $_;
	push @argv, $ARGV;
}

my $date = "";
my $name = "";
my $street = "";
my $directions = "";
my $turns = "";

my $i;
for ($i = 0; $i <= $#lines; $i++) {
	if ($lines[$i] =~ /Start Date\s*:\s*(.*)/) {
		$date = $1;
		$date =~ s/,/ /g;
	}

	my $group = "x";

	if ($lines[$i] =~ /Turning Movement Data\s*$/ ||
	    $lines[$i] =~ /Groups Printed-?\s*(.*)/) {
		my @directions = ();

		if ($lines[$i] =~ /Turning Movement Data/) {
			$i++;

			if ($lines[$i] eq "Start Time") {
				$i++;
			}

			$street = $lines[$i];
			$street =~ s/,/ /g;
			$i++;

			$directions = $lines[$i];
			$i++;
			@directions = split(/ /, $directions);
		} else {  # Groups Printed
			$i++;
			$group = $1;

			my %street = ();
			$street = "";
			for (; $i <= $#lines; $i++) {
				last if $lines[$i] =~ /Start Time/;

				if ($lines[$i] =~ /(North|South|East|West)bound/ ||
				    $lines[$i] =~ /(Northeast|Southeast|Northwest|Southwest)bound/ ||
				    $lines[$i] =~ /From (North|South|East|West)/ ||
				    $lines[$i] =~ /From (Northeast|Southeast|Northwest|Southwest)/) {
					$lines[$i] =~ s/From Northwest/Southeastbound/g;
					$lines[$i] =~ s/From Northeast/Southwestbound/g;
					$lines[$i] =~ s/From Southwest/Northeastbound/g;
					$lines[$i] =~ s/From Southeast/Northeastbound/g;
					$lines[$i] =~ s/From North/Southbound/g;
					$lines[$i] =~ s/From East/Westbound/g;
					$lines[$i] =~ s/From South/Northbound/g;
					$lines[$i] =~ s/From West/Eastbound/g;

					push @directions, split(/ +/, $lines[$i]);
				} else {
					if (!defined($street{$lines[$i]})) {
						if ($street eq "") {
							$street = $lines[$i];
						} else {
							$street .= " / $lines[$i]";
						}
						$street{$lines[$i]} = 1;
					}
				}
			}
		}

		$turns = $lines[$i];
		$i++;
		while (! ($lines[$i] =~ /\d+:\d/ || $lines[$i] =~ /\d\.\d/)) {
			$turns .= " $lines[$i]";
			$i++;
		}
		$turns =~ s/App *. *Total/App.Total/gi;
		$turns =~ s/Int *. *Total/Int.Total/gi;
		$turns =~ s/Exclu *. *Total/Exc.Total/gi;
		$turns =~ s/Inclu *. *Total/Inc.Total/gi;
		$turns =~ s/R *i *g *h *t/Right/gi;
		$turns =~ s/L *e *f *t/Left/gi;
		$turns =~ s/P *e *d *s/Peds/gi;
		$turns =~ s/T *h *r *u/Thru/gi;
		$turns =~ s/H *a *r *d */Hard/gi;
		$turns =~ s/S *o *f *t */Soft/gi;
		$turns =~ s/B *e *a *r */Bear/gi;
		$turns =~ s/U *- *T *u *r *n/U-Turn/gi;
		$turns =~ s/ *n *o *t *a *l *l *o *w *e *d/notallowed/gi;
		$turns =~ s/([NSEW]) *S *i *d *e /\1Side/gi;
		$turns =~ s/ *Xing *([NSEW])B/Xing\1B/gi;
		$turns =~ s/Start *Time *//g;
		my @turns = split(/ +/, $turns);

		if ($group eq "BIKES" ||
		    $group eq "Bikes" ||
		    $group eq "2 - Bicycles" ||
		    $group eq "2 - 2 - Bicycles" ||
		    $group eq "Bicycles" ||
		    $group eq "BIKES PEDS") {
			for (my $x = 0; $x <= $#turns; $x++) {
				if ($turns[$x] eq "Right") {
					$turns[$x] = "RightBikes";
				} elsif ($turns[$x] eq "Left") {
					$turns[$x] = "LeftBikes";
				} elsif ($turns[$x] eq "Thru") {
					$turns[$x] = "ThruBikes";
				}
			}
		}

		# print "street $street\n";
		# print "directions $directions\n";
		# print "turns $turns\n";

		my %count = ();

		for (; $i <= $#lines; $i++) {
			if ($lines[$i] =~ s/\s*(\d+):(\d+) (.M)?\s*//) {  # will also pick up ^L-prefixed
				my $hour = $1;
				my $minute = $2;
				my $m = $3;

				if ($m eq "PM" && $hour != 12) {
					$hour += 12;
				}
				my $when = $hour * 60 + $minute;

				last if defined($count{$when});

				my $line = $lines[$i];
				while ($lines[$i + 1] =~ /^\d+$/ || $lines[$i + 1] =~ /^\d+\s/) {
					$line .= " $lines[$i + 1]";
					$i++;
				}

				my @fields = split(/ +/, $lines[$i]);
				if ($#fields != $#turns) {
					print STDERR "$argv[$i]: Mismatched fields ($#fields) and turns ($#turns)\n";
					print STDERR "$argv[$i]: fields are $lines[$i]\n";
					print STDERR "$argv[$i]: turns are $turns\n";
				} else {
					my $state = 0;
					my $direction = 0;
					my $j;
					for ($j = 0; $j <= $#fields; $j++) {
						if ($turns[$j] =~ /Total/) {
							$state = 1;
						} elsif ($state == 1) {
							$state = 0;
							$direction++;
						} elsif (defined($count{$when}{$directions[$direction]}{$turns[$j]})) {
							$state = 0;
							$direction++;
						}

						# print "count{$when}{$directions[$direction]}{$turns[$j]} = $fields[$j]\n";
						$count{$when}{$directions[$direction]}{$turns[$j]} = $fields[$j];
					}
				}
			} elsif ($lines[$i] =~ /Hourly Total/ ||
			         $lines[$i] =~ /^Total/ ||
				 $lines[$i] =~ /^Factor/ ||
				 $lines[$i] eq "*** BREAK ***") {
				;
			} else {
				# print "skipping out $lines[$i]\n";
				last;
			}
		}

		for my $when (sort {$a <=> $b } (keys(%count))) {
			print "$argv[$i],$street,$group,$date,";
			printf("%02d:%02d-%02d:%02d,", $when / 60, $when % 60, ($when + 15) / 60, ($when + 15) % 60);

			# Directions to intersection legs
			my %bikemap = ( "Northbound" => "Westbound",
			                "Southbound" => "Eastbound",
			                "Eastbound" => "Northbound",
			                "Westbound" => "Southbound");

			for my $direction (keys(%bikemap)) {
				if (defined($count{$when}{$direction}{"ThruBikes"})) {
					$count{$when}{$bikemap{$direction}}{"Bikes"} =
						$count{$when}{$direction}{"ThruBikes"};
					delete $count{$when}{$direction}{"ThruBikes"};
				}
			}

			for my $direction ('Southbound', 'Westbound', 'Northbound', 'Eastbound') {
				for my $turn ('Right', 'Thru', 'Left') {
					print "$count{$when}{$direction}{$turn},";
					delete $count{$when}{$direction}{$turn};
				}
			}

			for my $turn ('Peds', 'Bikes') {
				for my $direction ('Southbound', 'Westbound', 'Northbound', 'Eastbound') {
					print "$count{$when}{$direction}{$turn},";
					delete $count{$when}{$direction}{$turn};
				}
			}

			print ",";  # XXX

			for my $direction (keys(%{$count{$when}})) {
				for my $turn (keys(%{$count{$when}{$direction}})) {
					next if $turn =~ /Total/;
					next if $turn =~ /U-Turn/;
					next if $turn =~ /RightBikes/;
					next if $turn =~ /LeftBikes/;

					print ",$direction:$turn:$count{$when}{$direction}{$turn}";
				}
			}

			print "\n";
		}
	}
}
